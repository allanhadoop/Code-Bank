—————————— Kernel API ————————— 
——————Linked list - http://www.roman10.net/2011/07/28/linux-kernel-programminglinked-list/
————— https://isis.poly.edu/kulesh/stuff/src/klist/
——————— https://linux-kernel-labs.github.io/master/labs/kernel_api.html?highlight=init_list_head

Data types arch Size: i686 
char 	1
short 	2
int 	4
long 	4
ptr 	4
long-long 	8
u8 		1
u16 	2
u32 	4
u64  	8

Check kernel version using name -r
— API Covered 
1. Linked List
2. Atomic lock
3. Spinlock 
4. Proc file 
5. CPU time usage
6. Waiting queues
7. USB Driver 
8. iotcl - input/output character device
———————— ———————————— Linked List ———————————————————  ————————————

#include <linux/slab.h>
#include <linux/kernel.h>
#include <linux/list.h>
#include <linux/module.h>
#include <linux/string.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("this is sample description");
MODULE_AUTHOR("Test user");

//There are three types of pointers as below .
//1. Main linked list which is called stack list 
//2. newstack - This is used to add new list to main stack list 
//3. PrintstackPlaceholder - This is used to print elements of stack list 
//4. cleanupstack - This is to clean the list from memory.

struct stackdetails { 
	char name[30];
	unsigned int age;
	struct list_head list;
};

struct stackdetails stacklist;

int init_module() {

	struct stackdetails *newstack  ;
 	INIT_LIST_HEAD(&stacklist.list);
	
	unsigned int i;
	for(i=0 ; i<5 ; i++) {
		newstack = kmalloc(sizeof(*newstack), GFP_KERNEL);
		strcpy(newstack->name , "terminalstack");
		newstack->age = 3;
		INIT_LIST_HEAD(&newstack->list);

		list_add_tail(&(newstack->list),&(stacklist.list));		
	}

	printk(KERN_INFO "Traversing the list using the list\n");

	struct stackdetails *PrintstackPlaceholder;
	list_for_each_entry(PrintstackPlaceholder, &stacklist.list, list) { 
		printk(KERN_INFO "Name : %s ; age:%d" , PrintstackPlaceholder->name, PrintstackPlaceholder->age);
	}
	printk(KERN_INFO "---Done----");
	return 0;
}

void cleanup_module() { 
	struct stackdetails *cleanupstack , *tmp;
	printk(KERN_INFO "Kernel module uploaded---\n");
	printk(KERN_INFO "Delete the list below\n");
	list_for_each_entry_safe(cleanupstack, tmp, &stacklist.list, list) { 
		printk(KERN_INFO "Freeing node one by one %s\n", cleanupstack->name);
		list_del(&cleanupstack->list);
		kfree(cleanupstack);
	}
	
}

————————— output ———————————— 
[255138.327389] ----Initializing kernal module here ----
[255138.327392] Traversing the list using the list
[255138.327395] Name : terminalstack ; age:3
[255138.327396] Name : terminalstack ; age:3
[255138.327397] Name : terminalstack ; age:3
[255138.327398] Name : terminalstack ; age:3
[255138.327399] Name : terminalstack ; age:3
[255138.327399] ---Done----
——————————— ———  —— - ———————  ——————— -  ———————  Another program ————— 
#include <linux/slab.h>
#include <linux/list.h>

struct pid_list {
    pid_t pid;
    struct list_head list;
};

LIST_HEAD(my_list);

pid = 200;
static int add_pid(pid_t pid)
{
    struct pid_list *ple = kmalloc(sizeof *ple, GFP_KERNEL);
	
    if (!ple)
        return -ENOMEM;
    printk("pid number -----%d" , pid);

    ple->pid = pid;
    list_add(&ple->list, &my_list);

    return 0;
}

static int del_pid(pid_t pid)
{
    struct list_head *i, *tmp;
    struct pid_list *ple;

    list_for_each_safe(i, tmp, &my_list) {
        ple = list_entry(i, struct pid_list, list);

        if (ple->pid == pid) {
            list_del(i);
            kfree(ple);
            return 0;
        }
    }

    return -EINVAL;
}

static void destroy_list(void)
{
    struct list_head *i, *n;
    struct pid_list *ple;

    list_for_each_safe(i, n, &my_list) {
        ple = list_entry(i, struct pid_list, list);
        list_del(i);
        kfree(ple);
    }
}
———————— ———————————— Atomic Lock Operations ———————————————————  ————————————
——atomic_t is is mainly used for counters.

#include <linux/module.h>
#include <linux/types.h>
#include <linux/init.h>


atomic_t a;

static int __init atomic_init(void) { 
        printk("-----------");
	atomic_set(&a , 20);
	printk(KERN_INFO "%d--initial set value\n", atomic_read(&a));
	
	atomic_add_unless(&a, 15, 20);   //here no addition will happen if source &a matches to third parameter (20) 
        printk(KERN_INFO "%d--updated set\n", atomic_read(&a));

// Atomic compare and exchange cmpxchg - While system does compare and replace, it is locked down, no other process 
// can change it.

	atomic_set(&a, 4);
	printk(KERN_INFO "%d--original set\n", atomic_read(&a));

	atomic_cmpxchg(&a, 4, 7);  	// if incoming value of a matched with 4 then replace it with 7
	printk(KERN_INFO "%d--updated set\n", atomic_read(&a));

	atomic_cmpxchg(&a, 7, 8);    // if now updated 7 matches with 7 (Second argument) then replace with 8
	printk(KERN_INFO "%d--second updated set\n", atomic_read(&a));	

// Atomic Decrement 
	atomic_set(&a, 10);
	printk(KERN_INFO "%d--initial set value\n", atomic_read(&a));
	atomic_dec(&a);
	printk(KERN_INFO "%d--initial set value\n", atomic_read(&a));
	
//Atomic Increment 
	atomic_set(&a, 23);
	printk(KERN_INFO "%d--initial set value\n", atomic_read(&a));
	atomic_inc(&a);
	printk(KERN_INFO "%d--initial set value\n", atomic_read(&a));



// Atomic Decrement and test 
	int num ;
	int ret;
	atomic_set(&a, 4);
	printk(KERN_INFO "%d--initial set value\n", atomic_read(&a));
	ret = num = 0;
	while ((ret = atomic_dec_and_test(&a)) == 0){
		num ++;
	        printk(KERN_INFO "%d--initial set value\n", atomic_read(&a));
	}
	printk(KERN_ALERT "num = %d\n", num);

// Atomic sub return 
	atomic_set(&a, 6);
	printk(KERN_INFO "%d--initial set value\n", atomic_read(&a));
	atomic_sub_return(13, &a);
	printk(KERN_INFO "%d--initial set value\n", atomic_read(&a));

	
	return 0;
}

static void __exit atomic_exit(void) { 
	printk(KERN_ALERT "--Done processing -----\n");	
}

module_init(atomic_init);
module_exit(atomic_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("test");

—— ————— ———— outcome —— ———
[587958.376266] -----------
[587958.376270] 20--initial set value
[587958.376296] 20--updated set
[587958.376298] 4--original set
[587958.376299] 7--updated set
[587958.376299] 8--second updated set
[587958.376300] 10--initial set value
[587958.376301] 9--initial set value
[587958.376302] 23--initial set value
[587958.376303] 24--initial set value
[587958.376304] 4--initial set value
[587958.376305] 3--initial set value
[587958.376306] 2--initial set value
[587958.376306] 1--initial set value
[587958.376307] num = 3
[587958.376309] 6--initial set value
[587958.376310] -7--initial set value

———————— ———————————— Spinlock ———————————————————  ————————————
When two or more processes require dedicated access to a shared resource, they might need to enforce the condition that they are the sole process to operate in a given section of code. The basic form of locking in the Linux kernel is the spinlock. Spinlocks take their name from the fact that they continuously loop, or spin, waiting to acquire a lock. The drawback of spinlocks is that they busily loop, waiting for the lock to be freed. They are best used for critical sections of code that are fast to complete. For code sections that take time, it is better to use another Linux kernel locking utility: the semaphore. Semaphores differ from spinlocks because the task sleeps, rather than busy waits, when it attempts to obtain a contested resource. One of the main advantages is that a process holding a semaphore is safe to block; they are SMP and interrupt safe: Both architecture implementations provide a pointer to a wait_queue and a count. The count is the number of processes that can hold the semaphore at the same time. With semaphores, we could have more than one process entering a critical section of code at the same time. If the count is initialized to 1, only one process can enter the critical section of code; a semaphore with a count of 1 is called a mutex.

http://www.informit.com/articles/article.aspx?p=414983&seqNum=3

——— 
spin_lock_irqsave is basically used to save the interrupt state before taking the spin lock, this is because spin lock disables the interrupt, when the lock is taken in interrupt context, and re-enables it when while unlocking. The interrupt state is saved so that it should reinstate the interrupts again.

Example:

Lets say interrupt x was disabled before spin lock was acquired
spin_lock_irq will disable the interrupt x and take the the lock
spin_unlock_irq will enable the interrupt x.
So in the 3rd step above after releasing the lock we will have interrupt x enabled which was earlier disabled before the lock was acquired.

So only when you are sure that interrupts are not disabled only then you should spin_lock_irq otherwise you should always use spin_lock_irqsave.

#include <linux/module.h>

#include <linux/kernel.h>

#include <linux/kthread.h>

#include <linux/spinlock_types.h>

#include <linux/fs.h>

#include <linux/cdev.h>

#include <linux/delay.h>

#include <asm/uaccess.h>




#define LOOPS 100000




static int list[LOOPS];

static int idx = 0, cs1 = 0, cs2 = 0;

static struct task_struct *t1, *t2;

static spinlock_t spinlock;




static int consumer(void* ptr)

{

	unsigned long flags = 0;

	printk(KERN_INFO "Consumer TID %d\n", (int)ptr);




	while (1) 

	{

		spin_lock_irqsave(&spinlock, flags);

		if (idx >= LOOPS)

		{

			spin_unlock_irqrestore(&spinlock, flags);

			break;

		}

		list[idx++] += 1;

		spin_unlock_irqrestore(&spinlock, flags);

		if ((int)ptr == 1)

			cs1++;

		else

			cs2++;

	}

	printk(KERN_INFO "Consumer %d done\n", (int)ptr);

	return 0;

}




static int spinlock_init(void)

{

	int i, id1 = 1, id2 = 2, lo_cnt = 0, hi_cnt = 0;

	for (i = 0; i < LOOPS; i++)

		list[i] = 0;




	spin_lock_init(&spinlock);




	t1 = kthread_create(consumer, (void*)id1, "cons1");

	t2 = kthread_create(consumer, (void*)id2, "cons2");




	if (t1 && t2) {

		printk(KERN_INFO "Starting...\n");

		wake_up_process(t1);

		wake_up_process(t2);

	} else {

		printk(KERN_EMERG "Error\n");

	}




	msleep(100);




	for (i = 0; i < LOOPS; i++) {

		if (list[i] == 0) {

			lo_cnt++;

			printk(KERN_INFO "lo:%d ", i);

		} else if (list[i] > 1) {

			hi_cnt++;

			printk(KERN_INFO "hi: %d ", i);

		}

	}

	printk(KERN_INFO "lo_cnt = %d hi_cnt = %d cs1 = %d cs2 = %d\n", lo_cnt, hi_cnt, cs1, cs2);

	return 0;

}




void spinlock_cleanup(void)

{

	printk(KERN_INFO "Inside cleanup_module\n");

}




MODULE_LICENSE("GPL");

MODULE_AUTHOR(“TEST”);

MODULE_DESCRIPTION("Simple kernel module which demonstrates using of spinlock");

module_init(spinlock_init);

module_exit(spinlock_cleanup);
————Output — 
…(run this program and see the output) 

————— —————— Another example —————— run and see output yourself
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/semaphore.h>
#include <linux/kthread.h>  // for threads
#include <linux/sched.h>  // for task_struct
#include <linux/time.h>
#include <linux/timer.h>
#include <linux/delay.h>

#define DEFINE_SPINLOCK(x)    spinlock_t x = __SPIN_LOCK_UNLOCKED(x)
static struct task_struct *thread1,*thread2;
static DEFINE_SPINLOCK(my_lock) ;

//static spinlock_t my_lock = SPIN_LOCK_UNLOCKED;

int thread_fn1() {
unsigned long j0,j1;
int delay = 60*HZ;
j0 = jiffies;
j1 = j0 + delay;
spin_lock(&my_lock);
while (time_before(jiffies, j1))
  schedule();
spin_unlock(&my_lock);
return 0;
}

int  thread_fn2() {
int ret=0;
msleep(100);
ret=spin_trylock(&my_lock);
if(!ret) {
 printk(KERN_INFO "Unable to hold lock");
 return 0;
} else {
printk(KERN_INFO "Lock acquired");
spin_unlock(&my_lock);
return 0;
}
}



int thread_init (void) {
 char name[8]="thread1";
 char name1[8]="thread2";
 thread1 = kthread_create(thread_fn1,NULL,name);
 if((thread1))
  {
  wake_up_process(thread1);
  }
 thread2 = kthread_create(thread_fn2,NULL,name1);
 if((thread2))
  {
  wake_up_process(thread2);
  }
 return 0;
}



void thread_cleanup(void) {
 int ret,ret1;
 ret = kthread_stop(thread1);
 if(!ret)
  printk(KERN_INFO "Thread stopped");

}
MODULE_LICENSE("GPL"); 
module_init(thread_init);
module_exit(thread_cleanup);


—————— ——————— Dealing with /proc files. ————— simple read/write operation ——————————
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include<linux/sched.h>
#include <asm/uaccess.h>
#include <linux/slab.h>

int len,temp;

char *msg;

int test_read_proc(struct file *filp,char *buf,size_t count,loff_t *offp ) {
if(count>temp){
count=temp; }
temp=temp-count;
copy_to_user(buf,msg, count);
if(count==0)
temp=len;
return count;
}

int test_write_proc(struct file *filp,const char *buf,size_t count,loff_t *offp) {
printk(KERN_INFO "Value of count from write_fops - %d -------", count);
copy_from_user(msg,buf,count);
len=count;
temp=len;
return count;
}

struct file_operations test_proc_fops = {
read: test_read_proc,
write: test_write_proc
};


void test_create_new_proc_entry() {
proc_create("hello",0,NULL,&test_proc_fops);
msg=kmalloc(GFP_KERNEL,10*sizeof(char));
}


int proc_init (void) {
 test_create_new_proc_entry();
 return 0;
}

void proc_cleanup(void) {
 remove_proc_entry("hello",NULL);
 printk(KERN_INFO "-------------Done processing------------");
}

MODULE_LICENSE("GPL"); 
module_init(proc_init);
module_exit(proc_cleanup);

—————————Makefile below  — ————
obj-m += k_3_10.o

KDIR = /usr/src/kernels/3.10.0-693.el7.x86_64

all:
	make -C /usr/src/kernels/3.10.0-693.el7.x86_64/ M=$(PWD) modules

clean : 
	make -C /usr/src/kernels/3.10.0-693.el7.x86_64/ M=$(PWD) clean
—————————output — ————
> make 
> insmod k_3_10.ko
> echo "this data going to user buffer then to kernel" > /proc/hello 
> cat /proc/hello 
this data going to user buffer then to kernel
—————————————————————————————————CPU Timer usage Example 1—————————————————————————
————EXAMNPLE 1 -  Simple timer API, getting response timer from kernel depending on parameter —————
//Readme file is very helpful at https://github.com/danghai/Kernel/blob/master/time_jiffies/time_example1.c
/* 
	j = jiffies;                      /* read the current value */
	stamp_1    = j + HZ;              /* 1 second in the future */ s
	tamp_half = j + HZ/2;             /* half a second */
	stamp_n    = j + n * HZ / 1000;   /* n milliseconds */
/*
*   time_example1.c: It is a simple kernel module that demonstrates
*   the core aspects of the simple timer API. You set the parameter to
*   get reponse from Kernel. Ex: sudo insmod time_example1.ko value=3. It will
*   response after 3 seconds.
*/

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/timer.h>
#include <linux/moduleparam.h>

#define SUCCESS 0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Test user ");

static struct timer_list my_timer;
static int value;
module_param(value,int,S_IRUSR | S_IWUSR);

void my_timer_response (unsigned long data)
{
  printk(KERN_INFO "My timer response (%ld) . \n",jiffies);
}

static int __init time_example1_init(void)
{
  int ret;
  printk(KERN_INFO "Timer module installing ...\n");
  setup_timer (&my_timer, my_timer_response, 0);

  printk(KERN_INFO "Starting timer to fire in %d seconds (jiffies = %ld) \n",value,jiffies);
  ret = mod_timer(&my_timer,jiffies + value*HZ);
  if (ret)
    printk(KERN_INFO "Error in mod_timer\n");
  return SUCCESS;
}

static void __exit time_example1_exit(void)
{
  int ret;
  ret = del_timer( &my_timer );
  if (ret)
    printk("The timer is still in use...\n");

  printk("Timer module uninstalling ...\n");
}

module_init(time_example1_init);
module_exit(time_example1_exit);
————— output - ————— 
insmod time_example1.ko value=3
——check dmesg ——————————     —————— —————————

—————————————————————————————————CPU Timer usage Example 2—————————————————————————

———EXAMPLE 2- Simple timer API, getting response timer from kernel depending on factor — 

//https://github.com/danghai/Kernel/blob/master/time_jiffies/time_example2.c

/*
*	time_example2.c: provides a simple kernel module that demonstrates the core aspects of the
* 	simple timer API. Within `init_module`, you initialize a timer with `setup_timer` and then kick it off with a call to `mod_timer`. When the timer expires depending on factor, the callback function `timer_response` is invoked. The timer response will be :
* 	1s --> 2s --> 3s --> 4s ....
*/


#include <linux/module.h>
#include <linux/types.h>
#include <linux/time.h>

MODULE_LICENSE("GPL/BSD");
MODULE_AUTHOR("test");
MODULE_VERSION("0.1");
//timer structure 
struct timer_list my_timer;

//structure for factor and respective jiffies
static struct my_struct {
	int factor;
	unsigned long jiff_variable;
} my_str;


//logic function
static void time_response(unsigned long data) { 
	
	struct my_struct *val = (struct my_struct* )data ;
	printk(KERN_INFO "factor=%u elapsed time = %lu\n", val->factor, val->jiff_variable);
	
	val->factor = val->factor + 3;
	val->jiff_variable = jiffies;
        printk(KERN_INFO "Updated factor=%u elapsed time = %lu\n", val->factor, val->jiff_variable);

//here we are adding factor to jiffies to get new value for expiry
	mod_timer(&my_timer, (jiffies + (val->factor * HZ))); 
}



//init function
static int __init time_example2_init(void) { 
	
	my_str.factor = 2;
	my_str.jiff_variable = jiffies;
//setup_timer(timer, callback_fn, cb_data)
	setup_timer(&my_timer, time_response, (unsigned long)&my_str) ;
//mod_timer(timer, expires)
	mod_timer(&my_timer,(jiffies + (1 * HZ)));

}


//exit function
static void __exit time_example2_exit(void) { 
	printk(KERN_INFO "Unloading timer");
//del_timer(timer)
	del_timer(&my_timer);
}



module_init(time_example2_init);
module_exit(time_example2_exit);
——out put ———
[86134.248010] factor=2 elapsed time = 4380800524
[86134.248025] Updated factor=5 elapsed time = 4380801526
[86139.249989] factor=5 elapsed time = 4380801526
[86139.250005] Updated factor=8 elapsed time = 4380806528
[86147.265978] factor=8 elapsed time = 4380806528
[86147.265991] Updated factor=11 elapsed time = 4380814544

——————— ——— Example 3- Blink LED Caps Locks with blink rate ————— 
// Blink LED Caps Locks with blink rate
//https://github.com/danghai/Kernel/blob/master/time_jiffies/time_example3.c


/*
* time_example3.c: provides a simple kernel module that demonstrates the core aspects of the
* simple timer API. It takes parameter to set the blink_rate. The LED on Caps Lock will
* blink with the blink_rate.
*/

#include <linux/module.h>
#include <linux/types.h>
#include <linux/time.h>
#include <linux/moduleparam.h>
#define CAPS_LED 4

MODULE_LICENSE("GPL/BSD");
MODULE_AUTHOR("test user");
MODULE_VERSION("0.1");

struct timer_list my_timer;


//  Struct: factor for call mod_timer, Jiff saves current LED status
static struct my_struct {
	unsigned char status_led ;
} my_str;

static int blink_rate = 2; // Set the default blink_rate
module_param(blink_rate,int,S_IRUSR | S_IWUSR);

static void timer_response(unsigned long data)
{
	struct my_struct *val = (struct my_struct *)data;

// Turn ON/OFF LED  Read keyboard status and send command 0xED to port 0x60 to set LED
  while((inb(0x64)&2)!=0){}
	  outb(0xED,0x60);
// Read keyboard status again and Send value to LED on keyboard 
  while((inb(0x64)&2)!=0){}
  	  outb(val->status_led,0x60);

// now update with the data: toogle LED 
	val->status_led = val->status_led  ^ CAPS_LED ;

// and restart the timer: 1s blinking 
	mod_timer(&my_timer, ((jiffies/blink_rate) + HZ));
}

static int __init time_example2_init(void)
{
	printk(KERN_INFO "%s started, HZ=%d\n", __func__, HZ);
	my_str.status_led = 0;
	setup_timer(&my_timer, timer_response, (unsigned long)&my_str);
	mod_timer(&my_timer, ((jiffies/blink_rate) + (1 * HZ)));
	return 0;
}

static void __exit time_example2_exit(void)
{
	del_timer_sync(&my_timer);
	printk(KERN_INFO "unloaded\n");
}

module_init(time_example2_init);
module_exit(time_example2_exit);

———— —————— Two timers ——————Example ————— 
// https://technologyasilearn.wordpress.com/tag/kernel-timers/

/*
 * Key Takeaways:
 * 1. How to use init_timer() and add_timer()
 * 2. How/where to use add_timer_on() and mod_timer_pinned()
 * 3. How to get CPU id (smp_processor_id())
 */
#include <linux/kthread.h>
#include <linux/slab.h>
#include <linux/spinlock_types.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/timer.h>        /* for timers apis */
#include <linux/delay.h>        /* for msleep() */
#include <linux/hardirq.h>      /* for in_interrupt(), in_atomic() , moved to preempt_mask.h, 3.0 onwards */

MODULE_DESCRIPTION("Usage of init_timer(), add_timer(), add_timer_on() and mod_timer_pinned()");

MODULE_AUTHOR("test user");

struct timer_list timer;
struct timer_list timer2;
unsigned long *data;
//spinlock_t data_lock = SPIN_LOCK_UNLOCKED;

#define DEFINE_SPINLOCK(x)    spinlock_t x = __SPIN_LOCK_UNLOCKED(x)
static DEFINE_SPINLOCK(data_lock) ;

void timer_func(unsigned long data)
{
        unsigned long *d = (unsigned long *)data;
        printk("%s() is running on CPU-%u\n", __FUNCTION__, smp_processor_id());
        spin_lock(&data_lock);
        (*d)--;
        printk("%s : data = %lu...\n",__FUNCTION__, *d);
        if (in_interrupt())
                printk("%s : In interrupt context...\n", __FUNCTION__);

        if (in_atomic())
                printk("%s : In atomic context...\n", __FUNCTION__);

        if ((*d) != 0) {

                printk(KERN_INFO "timer 1 - decrementing <data> faster\n");
                mod_timer(&timer, jiffies + msecs_to_jiffies(500));
        }
        spin_unlock(&data_lock);
}

void timer2_func(unsigned long data)
{
        unsigned long *d = (unsigned long *)data;
        printk("%s() is running on CPU-%u\n", __FUNCTION__, smp_processor_id());
        spin_lock(&data_lock);
        (*d)++;
        printk("%s : data = %lu***\n",__FUNCTION__, *d);

        if (in_interrupt())
                printk("%s : In interrupt context***\n", __FUNCTION__);

        if (in_atomic())
                printk("%s : In atomic context***\n", __FUNCTION__);

        if ((*d) != 0) {
		printk(KERN_INFO "timer2 - decrementing <data> faster\n");
                printk(KERN_INFO "scheduling it again and pinning to same CPU\n");
                mod_timer_pinned(&timer2, jiffies + msecs_to_jiffies(10));
        }
        spin_unlock(&data_lock);
}

int __init start_module(void)
{
        data = kmalloc(sizeof(unsigned long), GFP_KERNEL);
        *data = 10;
	printk(KERN_INFO "-----------------show begins here --------------");

        //create timer 1
        setup_timer(&timer, timer_func, (unsigned long)data);
        //set expiry time
        mod_timer(&timer, jiffies + msecs_to_jiffies(1000));
	printk(KERN_INFO "-------------------we are after timer1 function before timer2\n");

        //create timer 2
        init_timer(&timer2);
        timer2.function = timer2_func;
        timer2.expires = jiffies + msecs_to_jiffies(1000);
        timer2.data = (unsigned long)data;              //type-casting pointer to unsigned long
        printk(KERN_INFO "--------we are in timer2 definition before add timer on begins\n");
        //now schedule timer on specified CPU
        add_timer_on(&timer2, 1); //on CPU 1

        return 0;
}

void __exit stop_module(void)
{
        int i = 0;
        printk("%s() is running on CPU-%u\n", __FUNCTION__, smp_processor_id());
        while (timer_pending(&timer)) {
                printk("timer 1 is pending\n");
                msleep(100);
                i++;
                if (i == 5)
                        del_timer(&timer);
        }
        if (i == 0) {
                printk("deleting timer 1\n");
                del_timer(&timer);
        }

        i = 0;
        while (timer_pending(&timer2)) {
                printk("timer 2 is pending\n");
                msleep(100);
                i++;
                if (i == 5)
                        del_timer(&timer2);
        }
        if (i == 0) {
                printk("deleting timer 2\n");
                del_timer(&timer);
        }

        kfree(data);
        printk("exiting from module\n");

}

module_exit(stop_module);
module_init(start_module);
MODULE_LICENSE("GPL");

——— — -   ————— -   ————output —— ————— - ——
[98197.168334] -----------------show begins here --------------
[98197.168339] -------------------we are after timer1 function before timer2
[98197.168340] --------we are in timer2 definition before add timer on begins
[98198.167765] timer2_func() is running on CPU-1
[98198.167784] timer2_func : data = 11***
[98198.167789] timer2_func : In interrupt context***
[98198.167793] timer2_func : In atomic context***
[98198.167797] timer2 - decrementing <data> faster
[98198.167801] scheduling it again and pinning to same CPU
[98198.169736] timer_func() is running on CPU-1
[98198.169739] timer_func : data = 10...
[98198.169740] timer_func : In interrupt context...
[98198.169741] timer_func : In atomic context...
[98198.169742] timer 1 - decrementing <data> faster
[98198.177734] timer2_func() is running on CPU-1
[98198.177736] timer2_func : data = 11***

—————————————Waiting queues — Example 1 - Only scheduler ———————— - ——————— —————— ————————
//https://sysplay.in/blog/linux-kernel-internals/2015/10/waiting-blocking-in-linux-driver/

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <asm/uaccess.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/delay.h>

#define FIRST_MINOR 0
#define MINOR_CNT 1

static dev_t dev;
static struct cdev c_dev;
static struct class *cl;

int open(struct inode *inode, struct file *filp)
{
	printk(KERN_INFO "Inside open\n");
	return 0;
}

int release(struct inode *inode, struct file *filp)
{
	printk(KERN_INFO "Inside close\n");
	return 0;
}

ssize_t read(struct file *filp, char *buff, size_t count, loff_t *offp)
{
	printk(KERN_INFO "Inside read\n");
	printk(KERN_INFO "Scheduling out\n");
	schedule();
	printk(KERN_INFO "Woken up\n");
	return 0;
}

ssize_t write(struct file *filp, const char *buff, size_t count, loff_t *offp)
{
	printk(KERN_INFO "Inside Write\n");
	return 0;
}

struct file_operations fops =
{
	.read = read,
	.write = write,
	.open = open,
	.release = release
};

int schd_init (void)
{
	int ret;
	struct device *dev_ret;

	if ((ret = alloc_chrdev_region(&dev, FIRST_MINOR, MINOR_CNT, "wqd")) < 0)
	{
		return ret;
	}
	printk("Major Nr: %d\n", MAJOR(dev));

	cdev_init(&c_dev, &fops);

	if ((ret = cdev_add(&c_dev, dev, MINOR_CNT)) < 0)
	{
		unregister_chrdev_region(dev, MINOR_CNT);
		return ret;
	}

	if (IS_ERR(cl = class_create(THIS_MODULE, "chardrv")))
	{
		cdev_del(&c_dev);
		unregister_chrdev_region(dev, MINOR_CNT);
		return PTR_ERR(cl);
	}
	if (IS_ERR(dev_ret = device_create(cl, NULL, dev, NULL, "mychar%d", 0)))
	{
		class_destroy(cl);
		cdev_del(&c_dev);
		unregister_chrdev_region(dev, MINOR_CNT);
		return PTR_ERR(dev_ret);
	}
	return 0;
}

void schd_cleanup(void)
{
	printk(KERN_INFO " Inside cleanup_module\n");
	device_destroy(cl, dev);
	class_destroy(cl);
	cdev_del(&c_dev);
	unregister_chrdev_region(dev, MINOR_CNT);
}

module_init(schd_init);
module_exit(schd_cleanup);

MODULE_LICENSE("GPL");
MODULE_AUTHOR(“TEST”);
MODULE_DESCRIPTION("Waiting Process Demo");

—————out put ———at dmesg —————— 
$ insmod sched.ko
Major Nr: 244
$ cat /dev/mychar0
Inside open
Inside read
Scheduling out
Woken up

—————————————Waiting queues — Example 2 -now introduce task to put process out of run queue and let it wait till we interrupt using cntrl+C  ———————— - ——————— —————— ————————

ssize_t read(struct file *filp, char *buff, size_t count, loff_t *offp)
{
	printk(KERN_INFO "Inside read\n");
	printk(KERN_INFO "Scheduling out\n");
	set_current_state(TASK_INTERRUPTIBLE);
	schedule();
	printk(KERN_INFO "Woken up\n");
	return 0;
}


> insmod sched.ko
> now interrupt using cntrl+c and see dmesg log 
[ 7031.930220] Major Nr: 244
[ 7039.236148] Inside open
[ 7039.236175] Inside read
[ 7039.236176] Scheduling out
[ 7049.763072] process woken up
[ 7049.763177] Inside close/release 
> rmmod sched
[ 7281.160504]  Inside cleanup_module

—————————————Waiting queues — Example 3 -this process is on indefinite wait till we interrupt manually using cntrl+C … below code shows how to tie this to event to wake it up ———————— - ——————— —————— ————————

//https://sysplay.in/blog/linux-kernel-internals/2015/11/waiting-blocking-in-linux-driver-part-2/


#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h> 
#include <linux/cdev.h>
#include <linux/device.h>
#include <asm/uaccess.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/delay.h>

#define FIRST_MINOR 0
#define MINOR_CNT 1

static dev_t dev;
static struct cdev c_dev;
static struct class *cl;
static struct task_struct *sleeping_task;

int open(struct inode *inode, struct file *filp)
{
	printk(KERN_INFO "Inside open\n");
	return 0;
}

int release(struct inode *inode, struct file *filp)
{
	printk(KERN_INFO "Inside close\n");
	return 0;
}

ssize_t read(struct file *filp, char *buff, size_t count, loff_t *offp)
{
	printk(KERN_INFO "Inside read\n");
	printk(KERN_INFO "Scheduling out\n");
	sleeping_task = current;
	set_current_state(TASK_INTERRUPTIBLE);
	schedule();
	printk(KERN_INFO "Woken up\n");
	return 0;
}

ssize_t write(struct file *filp, const char *buff, size_t count, loff_t *offp)
{
	printk(KERN_INFO "Inside Write\n");
	wake_up_process(sleeping_task);
	return count;
}

struct file_operations fops =
{
	.read = read,
	.write = write,
	.open = open,
	.release = release
};

int schd_init (void) 
{
	int ret;
	struct device *dev_ret;

	if ((ret = alloc_chrdev_region(&dev, FIRST_MINOR, MINOR_CNT, "wqd")) < 0)
	{
		return ret;
	}
	printk(KERN_INFO "Major Nr: %d\n", MAJOR(dev));

	cdev_init(&c_dev, &fops);

	if ((ret = cdev_add(&c_dev, dev, MINOR_CNT)) < 0)
	{
		unregister_chrdev_region(dev, MINOR_CNT);
		return ret;
	}

	if (IS_ERR(cl = class_create(THIS_MODULE, "chardrv")))
	{
		cdev_del(&c_dev);
		unregister_chrdev_region(dev, MINOR_CNT);
		return PTR_ERR(cl);
	}
	if (IS_ERR(dev_ret = device_create(cl, NULL, dev, NULL, "mychar%d", 0)))
	{
		class_destroy(cl);
		cdev_del(&c_dev);
		unregister_chrdev_region(dev, MINOR_CNT);
		return PTR_ERR(dev_ret);
	}
	return 0;
}

void schd_cleanup(void) 
{
	printk(KERN_INFO "Inside cleanup_module\n");
	device_destroy(cl, dev);
	class_destroy(cl);
	cdev_del(&c_dev);
	unregister_chrdev_region(dev, MINOR_CNT);
}

module_init(schd_init);
module_exit(schd_cleanup);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("test");
MODULE_DESCRIPTION("Waiting Process Demo");

————— out put —————— here we will wake up process using write() and echo process as given below instead of read interrupt process cntrl+C —————— ——————— 

$ echo 1 > /dev/mychar0
Inside open
Inside write
Woken up
Inside close
Inside close

—————————————Waiting queues — Example 4 -Here we are using IF condition to check if wakeup event is fired——————— - ——————— —The process will wake up only if the flag is set to ‘y’.————— ————————

//https://sysplay.in/blog/linux-kernel-internals/2015/11/waiting-blocking-in-linux-driver-part-2/

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h> 
#include <linux/cdev.h>
#include <linux/device.h>
#include <asm/uaccess.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/delay.h>


#define FIRST_MINOR 0
#define MINOR_CNT 1

static dev_t dev;
static struct cdev c_dev;
static struct class *cl;
static struct task_struct *sleeping_task;
static char flag;
static char buffer;

int open(struct inode *inode , struct file *filp) { 
	return 0;
} 

int release(struct inode *inode, struct file *filp) { 
	return 0;
} 

ssize_t read(struct file *filp, char *buff, size_t count , loff_t *offp) { 
	sleeping_task = current;
slp:
	if (flag != 'y') { 
		set_current_state(TASK_INTERRUPTIBLE);
		schedule();
	}
	if (flag == 'y')  
		printk(KERN_INFO "Woken up\n");
	else {
		printk(KERN_INFO "Interrupted by signal\n");
		goto slp;
	}
	flag = 'n';
	printk(KERN_INFO "Woken up\n");
	return 0;
} 

ssize_t write(struct file *filp, const char *buff, size_t count, loff_t *offp ) { 
        int ret;
	printk(KERN_INFO "Inside write now\n");
	ret = __get_user(flag, buffer);
	printk(KERN_INFO "%c", flag);
	wake_up_process(sleeping_task);
	return count;
} 

struct file_operations fops = { 
	.read = read,
	.write = write,
	.open = open,
	.release = release
};

int __init wakeup_init(void) {
	alloc_chrdev_region(&dev, FIRST_MINOR , MINOR_CNT, "wqd");
	cdev_init(&c_dev, &fops);	
	cdev_add(&c_dev, dev, MINOR_CNT);
} 


void __exit wakeup_clean(void) { 
	printk(KERN_INFO "Cleaning up drive\n");
	device_destroy(cl, dev);
	class_destroy(cl);
	cdev_del(&c_dev);
	unregister_chrdev_region(dev, MINOR_CNT);
} 


module_init(wakeup_init);
module_exit(wakeup_clean);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("test");
MODULE_DESCRIPTION("Wakeup event");

———— ————— output —— ——— ——————
$ echo 'y' > /dev/mychar0
Inside open
Inside write
Woken up
Inside close
Inside close
—————————— For above example, alternative is to use either statistic or dynamic wait queue as shown below 
#include <linux/wait.h>
// Data structure: wait_queue_head_t
// Created statically 
DECLARE_WAIT_QUEUE_HEAD(wait_queue_name);
// Created dynamically
wait_queue_head_t my_queue;
init_waitqueue_head(&my_queue);

—————actual example 
//https://sysplay.in/blog/linux-kernel-internals/2015/12/waiting-blocking-in-linux-driver-part-3/


#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/errno.h>
#include <asm/uaccess.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/delay.h>

#define FIRST_MINOR 0
#define MINOR_CNT 1

static char flag = 'n';
static dev_t dev;
static struct cdev c_dev;
static struct class *cl;
static DECLARE_WAIT_QUEUE_HEAD(wq);

int open(struct inode *inode, struct file *filp)
{
	printk(KERN_INFO "Inside open\n");
	return 0;
}

int release(struct inode *inode, struct file *filp) 
{
	printk (KERN_INFO "Inside close\n");
	return 0;
}

ssize_t read(struct file *filp, char *buff, size_t count, loff_t *offp) 
{
	printk(KERN_INFO "Inside read\n");
	printk(KERN_INFO "Scheduling Out\n");
	wait_event_interruptible(wq, flag == 'y');
	flag = 'n';
	printk(KERN_INFO "Woken Up\n");
	return 0;
}

ssize_t write(struct file *filp, const char *buff, size_t count, loff_t *offp) 
{   
	printk(KERN_INFO "Inside write\n");
	if (copy_from_user(&flag, buff, 1))
	{
		return -EFAULT;
	}
	printk(KERN_INFO "%c", flag);
	wake_up_interruptible(&wq);
	return count;
}

struct file_operations pra_fops = {
	read:        read,
	write:       write,
	open:        open,
	release:     release
};

int wq_init (void)
{
	int ret;
	struct device *dev_ret;

	if ((ret = alloc_chrdev_region(&dev, FIRST_MINOR, MINOR_CNT, "SCD")) < 0)
	{
		return ret;
	}
	printk("Major Nr: %d\n", MAJOR(dev));

	cdev_init(&c_dev, &pra_fops);

	if ((ret = cdev_add(&c_dev, dev, MINOR_CNT)) < 0)
	{
		unregister_chrdev_region(dev, MINOR_CNT);
		return ret;
	}

	if (IS_ERR(cl = class_create(THIS_MODULE, "chardrv")))
	{
		cdev_del(&c_dev);
		unregister_chrdev_region(dev, MINOR_CNT);
		return PTR_ERR(cl);
	}
	if (IS_ERR(dev_ret = device_create(cl, NULL, dev, NULL, "mychar%d", 0)))
	{
		class_destroy(cl);
		cdev_del(&c_dev);
		unregister_chrdev_region(dev, MINOR_CNT);
		return PTR_ERR(dev_ret);
	}
	return 0;
}

void wq_cleanup(void)
{
	printk(KERN_INFO "Inside cleanup_module\n");
	device_destroy(cl, dev);
	class_destroy(cl);
	cdev_del(&c_dev);
	unregister_chrdev_region(dev, MINOR_CNT);
}

module_init(wq_init);
module_exit(wq_cleanup);


MODULE_LICENSE("GPL");
MODULE_AUTHOR("test");
MODULE_DESCRIPTION("Waiting Process Demo");


————output —-
>insmod wait.ko
>cat /dev/mychar01
—this will get process blocked , now open another console and try below to give event as signal to wake up process
$ echo 'y' > /dev/mychar0
Inside open
Inside write
y
Inside close
Woken up
Inside close


————————————— USB driver ————————— - ——————— —————— ———————— 
//http://lmu.web.psi.ch/docu/manuals/software_manuals/linux_sl/usb_linux_programming_guide.pdf


// https://github.com/danghai/Kernel/blob/master/usb/example1/usb_driver.c

// https://github.com/danghai/Kernel/tree/master/usb/example1
#include <linux/module.h>

#include <linux/kernel.h>

#include <linux/usb.h>




#define VENDOR_ID 0x154b

#define PRODUCT_ID 0x00d4

MODULE_LICENSE("GPL");

MODULE_AUTHOR(“test”);

MODULE_DESCRIPTION("USB Pen Registration Driver");




static int pen_probe(struct usb_interface *interface, const struct usb_device_id *id)

{

    printk(KERN_INFO "Pen driver (%04X:%04X) plugged.\n", id->idVendor, id->idProduct);

    return 0;

}




static void pen_disconnect(struct usb_interface *interface)

{

    printk(KERN_INFO "Pen drive removed \n");

}




static struct usb_device_id pen_table [] =

{

  {USB_DEVICE(VENDOR_ID,PRODUCT_ID)},

  {}

};




MODULE_DEVICE_TABLE (usb, pen_table);

static struct usb_driver pen_driver =

{

    .name = "pen_driver",

    .id_table = pen_table,

    .probe = pen_probe,

    .disconnect = pen_disconnect,

};




static int __init pen_init(void)

{

    return usb_register(&pen_driver);

}




static void __exit pen_exit(void)

{

    usb_deregister(&pen_driver);

}




module_init(pen_init);

module_exit(pen_exit);
———— output ———— 
Before insmod the module, we need to deregister the default usb driver that PNY used.
the idVendor = 0x154b, idProduct = 0x00d4. usbcore: uas and usb-storage. You can check by command lsmod

deregister them by command:
//modprobe - Add and remove modules from the Linux Kernel
	sudo modprobe -r uas
	sudo modprobe -r usb_storage
Make, insmod, and rmmod the module:

	make
	sudo insmod usb_driver.ko
	sudo rmmod usb_driver.ko
The output should be in dmesg:

[  +2.109028] Pen driver (154B:00D4) plugged.
[  +0.001420] usbcore: registered new interface driver pen_driver
[Oct28 16:10] usbcore: deregistering interface driver pen_driver
[  +0.000013] Pen drive removed 	

———————— — —————— ——second example - https://github.com/danghai/Kernel/tree/master/usb/example2
 usb_driver.c and user.c programs . 
usb_driver.c below -
/*

*   usb_driver.c: A simple USB Pen registration Driver

*/

#include <linux/module.h>

#include <linux/kernel.h>

#include <linux/usb.h>

#include <linux/fs.h>

#include <linux/moduleparam.h>

#include <linux/kernel.h>

#include <linux/cdev.h>

#include <linux/types.h>

#include <linux/errno.h>

#include <linux/slab.h>

#include <asm/uaccess.h>




#define MIN(a,b) (((a) <= (b))? (a): (b))

#define BULK_OUT 0x02

#define BULK_IN 0x81

#define MAX_SIZE 512

#define VENDOR_ID 0x154b

#define PRODUCT_ID 0x00d4

#define USB_MINOR_BASE 0




//static struct usb_device *device;

//static struct usb_class_driver class;

static unsigned char bulk_buf[MAX_SIZE];




/* Structure to hold all of our device specific stuff */

struct usb_pen_driver {

    struct usb_device     *device;               /* the usb device for this device*/

    struct usb_interface  *interface;            /* the interface for this divce */

    unsigned char         *bulk_in_buffer;       /* the buffer to receive data */

    size_t                bulk_in_size;          /* the size of receive buffer */

    __u8                  bulk_in_endpointAddr;  /* the address of the bulk in endpoint*/

    __u8                  bulk_out_endpointAddr; /* the address of the bulk out endpoint*/

};







static int pen_open(struct inode *i, struct file *f)

{

  return 0;

}




static int pen_close(struct inode *i, struct file *f)

{

  return 0;

}




static ssize_t pen_read(struct file *f, char __user *buf, size_t cnt, loff_t *off)

{

  int retval;

  int read_cnt;

  struct usb_pen_driver *dev;

  dev = f->private_data;

  /* Read the data from the bulk endpoint */

  retval = usb_bulk_msg(dev->device,

                        usb_rcvbulkpipe(dev->device,dev->bulk_in_endpointAddr),

                        bulk_buf,

                        MIN(dev->bulk_in_size,cnt), &read_cnt,5000);




  /* If the read was successful, copy the data to userspace */

  if (retval)

  {

      printk(KERN_ERR "!Read: Bulk message returned %d\n", retval);

      return retval;

  }

  if (copy_to_user(buf,bulk_buf, MIN(cnt,read_cnt)))

      return -EFAULT;




  return MIN(cnt,read_cnt);

}




static ssize_t pen_write(struct file *f, const char __user *buf, size_t cnt, loff_t *off)

{

  int retval;

  int wrote_cnt = MIN (cnt, MAX_SIZE);

  struct usb_pen_driver *dev;

  dev = f->private_data;

  if(copy_from_user(bulk_buf,buf, MIN(cnt,dev->bulk_in_size)))

      return -EFAULT;

  retval = usb_bulk_msg(dev->device,

                        usb_sndbulkpipe(dev->device,

                        dev->bulk_out_endpointAddr),

                        bulk_buf,

                        MIN(cnt,dev->bulk_in_size), &wrote_cnt,5000);

  if(retval)

  {

      printk(KERN_ERR "!Write: bulk message returned %d\n", retval);

      return retval;

  }

  return wrote_cnt;

}




static struct file_operations fops =

{

    .owner    = THIS_MODULE,

    .open     = pen_open,

    .release  = pen_close,

    .read     = pen_read,

    .write    = pen_write,

};




/*

 * usb class driver info in order to get a minor number from the usb core

 * and to have the device registered with devfs and the driver core

 */




static struct usb_class_driver usb_class = {

  .name = "usb/pen%d",

  .fops = &fops,

};

static int pen_probe(struct usb_interface *interface, const struct usb_device_id *id)

{

    int retval;

    struct usb_pen_driver *dev;

    struct usb_host_interface *iface_desc;

    struct usb_endpoint_descriptor *endpoint;

    size_t buffer_size;

    int i;




    /* allocate memory for our device state and initialize it */

    dev = kzalloc(sizeof(*dev), GFP_KERNEL);

    if (!dev) {

      dev_err(&interface->dev, "Out of memory\n");

      return 1;

    }

        printk(KERN_INFO "Pen i/f %d driver (%04X:%04X) plugged.\n",iface_desc->desc.bInterfaceNumber,

          id->idVendor, id->idProduct);




    printk(KERN_INFO "ID->bNumEndpoints: %02X\n",

          iface_desc->desc.bNumEndpoints);




    printk(KERN_INFO "ID->bInterfaceClass: %02X\n",

              iface_desc->desc.bInterfaceClass);




    for ( i = 0; i < iface_desc->desc.bNumEndpoints; i++)

    {

          endpoint = &iface_desc->endpoint[i].desc;




          printk(KERN_INFO "ED[%d]->bEndpointAddress: 0x%02X\n",

                       i, endpoint->bEndpointAddress);

          printk(KERN_INFO "ED[%d]->bmAttributes: 0x%02X\n",

                       i, endpoint->bmAttributes);

          printk(KERN_INFO "ED[%d]->wMaxPacketSize: 0x%04X (%d)\n",

                       i, endpoint->wMaxPacketSize,

                       endpoint->wMaxPacketSize);




          buffer_size = endpoint->wMaxPacketSize;

          dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;

          dev->bulk_in_size =  buffer_size;

          //dev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);

    }

    dev->device = interface_to_usbdev(interface);




  //  class.name = "usb/pen%d";

  //  class.fops = &fops;

    if ((retval = usb_register_dev(interface, &usb_class)) < 0)

      printk(KERN_INFO "Not able to get a minor for this device. \n");

    else

      printk(KERN_INFO "Minor obtained: %d \n", interface ->minor);




    return retval;

}




static void pen_disconnect(struct usb_interface *interface)

{

    printk(KERN_INFO "Pen drive removed \n");

    usb_deregister_dev(interface, &usb_class);

}




static struct usb_device_id pen_table [] =

{

  {USB_DEVICE(VENDOR_ID,PRODUCT_ID)},

  {}

};




MODULE_DEVICE_TABLE (usb, pen_table);

static struct usb_driver pen_driver =

{

    .name = "pen_driver",

    .id_table = pen_table,

    .probe = pen_probe,

    .disconnect = pen_disconnect,

};




static int __init pen_init(void)

{

    return usb_register(&pen_driver);

}




static void __exit pen_exit(void)

{

    usb_deregister(&pen_driver);

}




MODULE_LICENSE("GPL");

MODULE_AUTHOR("Hai Dang Hoang");

MODULE_DESCRIPTION("USB Pen Registration Driver");

module_init(pen_init);

module_exit(pen_exit);

——— ———— —— user.c program below — 
#include <stdio.h>

#include <unistd.h>

#include <sys/types.h>

#include <sys/stat.h>

#include <fcntl.h>

#include <string.h>

#include <stdlib.h>

#include <errno.h>

int main(int argc, char *argv[])

{

    int fd;

    ssize_t num_read, num_written;

    char my_read_str[100];

    /* Open kernel */

    fd = open("/dev/pen0", O_RDWR);

    if (fd==-1)

    {

        perror("Cannot open file description from kernel \n");

        return -1;

    }




    /* Read value data from kernel */

    num_read = read(fd, &my_read_str, 100);

    if (num_read==-1) /* Check error*/

    {

        perror("Cannot read information from kernel \n");

        return -1;

    }

    printf("returned %d from the system call, num bytes read: %d\n",*my_read_str, (int)num_read);




    /* Write back the new value data to kernel */

    num_written = write(fd, argv[1], sizeof(argv[1]));

    if (num_written==-1) /* Check error */

    {

        perror("Cannot write back to kernel \n");

        return -1;

    }

    printf("successfully wrote %s (%d bytes) to the kernel\n", argv[1],(int)num_written);




    close(fd);




    return 0;

}
———— — —— ————— output —— —— ———— - ———
>make
>insmod user_driver.ko
>cc user.c -o user
>rmmod user_driver
>dmesg

————————— ——————————— ioctl - input/output character device ——————  —————— 
//https://opensourceforu.com/2011/08/io-control-in-linux/
Another example - 
//https://github.com/skuhl/sys-prog-examples/tree/master/kernel-module/chardev-ioctl

There are 4 programs - 1. query.ioctl.c , 2. query.ioctl.c , 3. query_app.c and 4. Makefile 
—— query.ipctl.c ———
//https://opensourceforu.com/2011/08/io-control-in-linux/
//Debugging the driver -- check header file for variables used ( status, query, ego)


#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/version.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/errno.h>
#include <asm/uaccess.h>
 
#include "query.ioctl.h"
 
#define FIRST_MINOR 0
#define MINOR_CNT 1
 
static dev_t dev;
static struct cdev c_dev;
static struct class *cl;
static int status = 1, dignity = 3, ego = 5;
 
static int my_open(struct inode *i, struct file *f)
{
    return 0;
}
static int my_close(struct inode *i, struct file *f)
{
    return 0;
}
#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
static int my_ioctl(struct inode *i, struct file *f, unsigned int cmd, unsigned long arg)
#else
static long my_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
#endif
{
    query_arg_t q;
 
    switch (cmd)
    {
        case QUERY_GET_VARIABLES:
            q.status = status;
            q.dignity = dignity;
            q.ego = ego;
            if (copy_to_user((query_arg_t *)arg, &q, sizeof(query_arg_t)))
            {
                return -EACCES;
            }
            break;
        case QUERY_CLR_VARIABLES:
            status = 0;
            dignity = 0;
            ego = 0;
            break;
        case QUERY_SET_VARIABLES:
            if (copy_from_user(&q, (query_arg_t *)arg, sizeof(query_arg_t)))
            {
                return -EACCES;
            }
            status = q.status;
            dignity = q.dignity;
            ego = q.ego;
            break;
        default:
            return -EINVAL;
    }
 
    return 0;
}
 
static struct file_operations query_fops =
{
    .owner = THIS_MODULE,
    .open = my_open,
    .release = my_close,
#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
    .ioctl = my_ioctl
#else
    .unlocked_ioctl = my_ioctl
#endif
};
 
static int __init query_ioctl_init(void)
{
    int ret;
    struct device *dev_ret;
 
 
    if ((ret = alloc_chrdev_region(&dev, FIRST_MINOR, MINOR_CNT, "query_ioctl")) < 0)
    {
        return ret;
    }
 
    cdev_init(&c_dev, &query_fops);
 
    if ((ret = cdev_add(&c_dev, dev, MINOR_CNT)) < 0)
    {
        return ret;
    }
     
    if (IS_ERR(cl = class_create(THIS_MODULE, "char")))
    {
        cdev_del(&c_dev);
        unregister_chrdev_region(dev, MINOR_CNT);
        return PTR_ERR(cl);
    }
    if (IS_ERR(dev_ret = device_create(cl, NULL, dev, NULL, "query")))
    {
        class_destroy(cl);
        cdev_del(&c_dev);
        unregister_chrdev_region(dev, MINOR_CNT);
        return PTR_ERR(dev_ret);
    }
 
    return 0;
}
 
static void __exit query_ioctl_exit(void)
{
    device_destroy(cl, dev);
    class_destroy(cl);
    cdev_del(&c_dev);
    unregister_chrdev_region(dev, MINOR_CNT);
}
 
module_init(query_ioctl_init);
module_exit(query_ioctl_exit);
 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("test");
MODULE_DESCRIPTION("Query ioctl() Driver");


————— query.ioctl.h ——— 
#ifndef QUERY_IOCTL_H
#define QUERY_IOCTL_H
#include <linux/ioctl.h>
 
typedef struct
{
    int status, dignity, ego;
} query_arg_t;
 
//below we are setting initial values of all 3 functions.
#define QUERY_GET_VARIABLES _IOR('q', 1, query_arg_t *)
#define QUERY_CLR_VARIABLES _IO('q', 2)
#define QUERY_SET_VARIABLES _IOW('q', 3, query_arg_t *)
 
#endif
————— — —query_app.c ———— ——— 
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
 
#include "query.ioctl.h"
 
void get_vars(int fd)
{
    query_arg_t q;
 
    if (ioctl(fd, QUERY_GET_VARIABLES, &q) == -1)
    {
        perror("query_apps ioctl get");
    }
    else
    {
        printf("Status : %d\n", q.status);
        printf("Dignity: %d\n", q.dignity);
        printf("Ego    : %d\n", q.ego);
    }
}
void clr_vars(int fd)
{
    if (ioctl(fd, QUERY_CLR_VARIABLES) == -1)
    {
        perror("query_apps ioctl clr");
    }
}
void set_vars(int fd)
{
    int v;
    query_arg_t q;
 
    printf("Enter Status: ");
    scanf("%d", &v);
    getchar();
    q.status = v;
    printf("Enter Dignity: ");
    scanf("%d", &v);
    getchar();
    q.dignity = v;
    printf("Enter Ego: ");
    scanf("%d", &v);
    getchar();
    q.ego = v;
 
    if (ioctl(fd, QUERY_SET_VARIABLES, &q) == -1)
    {
        perror("query_apps ioctl set");
    }
}
 
int main(int argc, char *argv[])
{
    char *file_name = "/dev/query";
    int fd;
    enum
    {
        e_get,
        e_clr,
        e_set
    } option;
 
    if (argc == 1)
    {
        option = e_get;
    }
    else if (argc == 2)
    {
        if (strcmp(argv[1], "-g") == 0)
        {
            option = e_get;
        }
        else if (strcmp(argv[1], "-c") == 0)
        {
            option = e_clr;
        }
        else if (strcmp(argv[1], "-s") == 0)
        {
            option = e_set;
        }
        else
        {
            fprintf(stderr, "Usage: %s [-g | -c | -s]\n", argv[0]);
            return 1;
        }
    }
    else
    {
        fprintf(stderr, "Usage: %s [-g | -c | -s]\n", argv[0]);
        return 1;
    }
    fd = open(file_name, O_RDWR);
    if (fd == -1)
    {
        perror("query_apps open");
        return 2;
    }
 
    switch (option)
    {
        case e_get:
            get_vars(fd);
            break;
        case e_clr:
            clr_vars(fd);
            break;
        case e_set:
            set_vars(fd);
            break;
        default:
            break;
    }
 
    close (fd);
 
    return 0;
}

——— —Makefile ————————— 
obj-m += query.ioctl.o

KDIR = /usr/src/kernels/3.10.0-693.el7.x86_64

all:
	make -C /usr/src/kernels/3.10.0-693.el7.x86_64/ M=$(PWD) modules

clean : 
	make -C /usr/src/kernels/3.10.0-693.el7.x86_64/ M=$(PWD) clean
—————— — Executing above setof program —— ———— ————
> make 
> insmod query.ioctl.ko
> cc query_app.c -o query
> dmesg
> ./query 
> ./query -c —to clear all three variable 
> ./query -s -to set all 3 variables , it will ask to enter values of 3 variables
> ./query -g -to get all 3 variables 
——————— ————— - —————— - ——————— - ———— - —— - — 


















